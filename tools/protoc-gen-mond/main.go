package main

import (
	"fmt"
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
)

func main() {
	p := MondPlugin{}
	protogen.Options{}.Run(p.Generate)
}

type MondPlugin struct {
}

func (p *MondPlugin) Generate(plugin *protogen.Plugin) error {
	fmt.Fprintf(os.Stderr, "Generate: %v\n", "doing...")
	f := plugin.Files[len(plugin.Files)-1]
	if len(f.Services) == 0 {
		return nil
	}

	fname := f.GeneratedFilenamePrefix + ".mond.go"
	gf := plugin.NewGeneratedFile(fname, f.GoImportPath)
	for _, s := range f.Services {
		fmt.Fprintf(os.Stderr, "Generate svc: %v\n", s.GoName)

		p.genImport(gf, f)
		p.genClient(gf, s)
		p.genServer(gf, s)
	}

	return nil
}

func (p *MondPlugin) genClient(gf *protogen.GeneratedFile, svc *protogen.Service) {
	serviceName := strings.ReplaceAll(svc.GoName, "Service", "")
	gf.P(fmt.Sprintf(`type Grpc%sServiceClient interface {`, serviceName))
	gf.P("Close() error")
	for _, method := range svc.Methods {
		gf.P(fmt.Sprintf(`%s(ctx context.Context, req *%s) (*%s, error)`, method.GoName,
			method.Input.GoIdent.GoName,
			method.Output.GoIdent.GoName,
		))
	}
	gf.P("}")

	gf.P(fmt.Sprintf(`
	type grpc%sServiceClient struct {
		client %sServiceClient
		conn   *grpc.ClientConn
	}`, serviceName, serviceName))

	for _, method := range svc.Methods {
		gf.P(fmt.Sprintf(`
	func (g *grpc%sServiceClient) %s(ctx context.Context, req *%s) (*%s, error) {
		return g.client.%s(ctx, req)
	}`,
			serviceName,
			method.GoName,
			method.Input.GoIdent.GoName,
			method.Output.GoIdent.GoName,
			method.GoName,
		))
	}
	gf.P(fmt.Sprintf(`func (m *grpc%sServiceClient) Close() error {
	return m.conn.Close()
}`, serviceName))

	upper := fmt.Sprintf(`
func GetGrpc%sServiceClient() (Grpc%sServiceClient, error){
	if env.GetAppState() != env.Starting {
		return nil, errors.New("必须在服务初始化时加载grpc client")
	}
	opt := config.GetGrpcClientOption("%s")
	target := "meta://%s"
	loadBalancingPolicy := "meta"
	if opt.Scheme == "DNS" {
	target = opt.Endpoint
	loadBalancingPolicy = "round_robin"
}
	options := []grpc.DialOption{
	grpc.WithTransportCredentials(insecure.NewCredentials()),
`, serviceName, serviceName, serviceName, serviceName)
	gf.P(upper)
	gf.P("grpc.WithDefaultServiceConfig(fmt.Sprintf(`" + `{"loadBalancingPolicy":"%s"}` + "`, loadBalancingPolicy)),")
	lower := fmt.Sprintf(`
	grpc.WithChainUnaryInterceptor(mgrpc.ClientMiddleware(opt)...),
}
for _, v := range mgrpc.DefaultDialOptions {
	options = append(options, v)
}
conn, err := grpc.Dial(target, options...)
	if err != nil {
		return nil, err
	}
	client := New%sServiceClient(conn)
	return &grpc%sServiceClient{client: client, conn: conn},nil
}
`, serviceName, serviceName)
	gf.P(lower)
}

func (p *MondPlugin) genServer(gf *protogen.GeneratedFile, svc *protogen.Service) {
	serviceName := strings.ReplaceAll(svc.GoName, "Service", "")
	gf.P(fmt.Sprintf(`type %sServiceServerImpl struct {`, serviceName))
	gf.P(fmt.Sprintf(`svc %sServiceServer`, serviceName))
	gf.P(`}`)

	gf.P(fmt.Sprintf(`func New%sServiceServerImpl(svc %sServiceServer) *%sServiceServerImpl {`, serviceName, serviceName, serviceName))
	gf.P(fmt.Sprintf(`return &%sServiceServerImpl{svc: svc}`, serviceName))
	gf.P(`}`)

	for _, method := range svc.Methods {
		gf.P(fmt.Sprintf(`
	func (m *%sServiceServerImpl) %s(ctx context.Context, req *%s) (*%s, error) {`,
			serviceName,
			method.GoName,
			method.Input.GoIdent.GoName,
			method.Output.GoIdent.GoName,
		))
		gf.P(fmt.Sprintf(`return m.svc.%s(ctx, req)}`, method.GoName))
	}
}

func (p *MondPlugin) genImport(gf *protogen.GeneratedFile, f *protogen.File) {
	gf.P("// Code generated by protoc-gen-mond. DO NOT EDIT.")
	gf.P("// source: " + *f.Proto.Name)
	gf.P()
	gf.P("package " + *f.Proto.Package)
	gf.P()
	gf.P("import (")
	gf.P(`"context"`)
	gf.P(`"errors"`)
	gf.P(`"fmt"`)
	gf.P()
	gf.P(`merr "mond/wind/err"`)
	gf.P(`mgrpc "mond/wind/grpc"`)
	gf.P(`"mond/wind/config"`)
	gf.P(`"mond/wind/env"`)
	gf.P()
	gf.P(`"google.golang.org/grpc"`)
	gf.P(`"google.golang.org/grpc/credentials/insecure"`)
	gf.P(")")
	gf.P()
	gf.P(`var (
		_ merr.ErrorCode
	)`)
	gf.P()
}
